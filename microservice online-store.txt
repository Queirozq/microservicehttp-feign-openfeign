no user-session-service que é pra validar a sessão dos meus microserviços, fiz uma classe com um UUID e um bollean valid e no controller botei o endpoint pra ver se o uuid que eu passar de argumento é o mesmo que eu botei hardcode.


no OnlineService pra eu me comunicar com meu user-session-service botei as dependecy feign core/feign slf4j e feign jackson, fiz a interface UserSessionClient onde ele vai chamar o endpoint do meu user-session-service com o uuid como parametro para ver se é o mesmo do que tá lá no user-session-service para validar, no feign configuration botei um bean da minha interface onde ele vai encodar e decodar JSON e o restante do endpoint do meu UserSessionService, e no validationFilter ele vai testar se o sessionId vindo no header é o mesmo do meu microserviço UserSessionClient, se for nulo ou não for igual/valido ele da forbidden, se não eu consigo acessar meu endpoint.


dependency feign jackson = pra encodar e decodar o json
dependency feign slf4j = pegar a lib do logging
-------------------------------------------------------------------------------------------------------

-pra ligar o logging do feign client
  no FeignConfiguration adicionar .logLevel(Logger.Level.FULL) e o logger um new Sl4fjLogger
  e logging.level.feign=DEBUG no application.properties
-------------------------------------------------------------------------------------------------------
@QueryMap annotation e como usar com feign client
 
  se a gente quiser passar mais de um argumento na validação a gente usa a annotation @QueryMap 
  e passa um map de String, Object, e no nosso filter a gente cria um map também e bota o sessionId
-------------------------------------------------------------------------------------------------------
Default method na interface UserSessionClient para enxugar e ajudar na manuntenção

fiz um default method para ele ser chamado toda vez que eu usar a implementação da interface onde vai criar o map e retornar a primeira implementação que chama o endpoint do user-session-service pra fazer a validação.

com isso meu filter ficou mais enxuto e eu crio agora um UUID e passo com fromString para o erro de formtação não cair no meu endpoint e sim no meu próprio filter.
-------------------------------------------------------------------------------------------------------
Usando POJOs para parametros da URL-

ao invés de ter um map com os parâmetros a gente pode fazer um pojo pra os atributos do meu pojo serem os parametros da url, nesse caso criei uma classe com 1 atributo que seria o sessionId para ser o parâmetro com getter setter hashcode allargs const e noargs const

e na interface no metodo do endpoint eu não recebo mais um map, e sim o pojo, e no default method eu retorno o metodo do endpoint recebendo uma instancia nova do meu pojo passando o sessionId
-------------------------------------------------------------------------------------------------------
@Headers with feign client - colocando dados JSON para criar novos produtos no sistema


Primeiro criei o inventory-service api onde vai ficar os produtos, stocks de produtos tudo em um banco de dado em memória que é um map no restcontroller, de resto é só olhar o código que da pra entender, tem o map, um produto sendo colocado no map, o endpoint post de /products retornando a resposta e recebendo o request. na classe de ProductRequest não tem ID pq quem faz o id é a api e não quem vai inserir no banco de dados.


Na minha api online-store-service eu fiz a interface que vai criar os produtos chamando a api do inventory, fiz o createProduct response e request, usando a annotation @Headers
no feignConfiguration botei o bean da minha interface e a url, depois criei 2 pojos para receber a request e retornar a response no controller
-------------------------------------------------------------------------------------------------------
Usando expander do @Param para  @PathVariables, RequestParam com feign client

Pra aceitar uma data OffsetDateTime usando expander primeiro precisamos transformar a data em milisegundos no invetoryservice api, usando um formatter e pro spring identificar, criar uma classe de configuração e registrar o novo formato, depois é só passar o parametro OffsetDateTime no endpoint que a gente quer testar, no caso do projeto no buy.

E no online-service api a gente botou na interface do feignClient o novo endpoint, e usou o expander do feignClient no parametro passando uma classe para transformar OffSet em expander

-------------------------------------------------------------------------------------------------------
Header dinamicos com FeignClient

pra passar header parametros dinamicos usando feign é só botar a annotation @HeaderMap e colocar no map os parametros que você quiser passar no header
-------------------------------------------------------------------------------------------------------
Definindo interface  para health checks ou qualquer resourcer repitido nos downstream services(outras apis)

-Se tiver um resource que vai se repetir nas interfaces que conectam com as outras apis da pra fazer uma interface específica com esse resource, e as interfaces que conectam com as apis só herdar dessa interface.

-No projeto a gente usou o actuator das duas apis para ver se as apis estavam UP, criando a interface BaseClient, as duas interfaces herdando ela, criando o AcuatorHealthResponse e o HealthResponse para trafegar as respostas, criando o controller HealthApi que vai ter uma List da interface BaseClient e meu spring vai saber que é todas as interfaces que herdam ela






















como escala um cara 


sistema monolitico
tecnica escalabilidade vertical  escalando memoria, escalando cpu aumentando processamento da maquina
quando para uma função todo o resto para



sistema microserviço
escalabilidade horizontal


microserviço
tecnica escalabilidade horizontal principio de responsabilidade unica facilidade para manunteção  porem complexidade na rede para sicronizar tudo

ausencia de estado




