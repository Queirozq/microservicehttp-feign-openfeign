no user-session-service que é pra validar a sessão dos meus microserviços, fiz uma classe com um UUID e um bollean valid e no controller botei o endpoint pra ver se o uuid que eu passar de argumento é o mesmo que eu botei hardcode.


no OnlineService pra eu me comunicar com meu user-session-service botei as dependecy feign core/feign slf4j e feign jackson, fiz a interface UserSessionClient onde ele vai chamar o endpoint do meu user-session-service com o uuid como parametro para ver se é o mesmo do que tá lá no user-session-service para validar, no feign configuration botei um bean da minha interface onde ele vai encodar e decodar JSON e o restante do endpoint do meu UserSessionService, e no validationFilter ele vai testar se o sessionId vindo no header é o mesmo do meu microserviço UserSessionClient, se for nulo ou não for igual/valido ele da forbidden, se não eu consigo acessar meu endpoint.


dependency feign jackson = pra encodar e decodar o json
dependency feign slf4j = pegar a lib do logging
-------------------------------------------------------------------------------------------------------

-pra ligar o logging do feign client
  no FeignConfiguration adicionar .logLevel(Logger.Level.FULL) e o logger um new Sl4fjLogger
  e logging.level.feign=DEBUG no application.properties
-------------------------------------------------------------------------------------------------------
@QueryMap annotation e como usar com feign client
 
  se a gente quiser passar mais de um argumento na validação a gente usa a annotation @QueryMap 
  e passa um map de String, Object, e no nosso filter a gente cria um map também e bota o sessionId
-------------------------------------------------------------------------------------------------------
Default method na interface UserSessionClient para enxugar e ajudar na manuntenção

fiz um default method para ele ser chamado toda vez que eu usar a implementação da interface onde vai criar o map e retornar a primeira implementação que chama o endpoint do user-session-service pra fazer a validação.

com isso meu filter ficou mais enxuto e eu crio agora um UUID e passo com fromString para o erro de formtação não cair no meu endpoint e sim no meu próprio filter.
-------------------------------------------------------------------------------------------------------
Usando POJOs para parametros da URL-

ao invés de ter um map com os parâmetros a gente pode fazer um pojo pra os atributos do meu pojo serem os parametros da url, nesse caso criei uma classe com 1 atributo que seria o sessionId para ser o parâmetro com getter setter hashcode allargs const e noargs const

e na interface no metodo do endpoint eu não recebo mais um map, e sim o pojo, e no default method eu retorno o metodo do endpoint recebendo uma instancia nova do meu pojo passando o sessionId
























como escala um cara 


sistema monolitico
tecnica escalabilidade vertical  escalando memoria, escalando cpu aumentando processamento da maquina
quando para uma função todo o resto para



sistema microserviço
escalabilidade horizontal


microserviço
tecnica escalabilidade horizontal principio de responsabilidade unica facilidade para manunteção  porem complexidade na rede para sicronizar tudo

ausencia de estado




